# Guide d'Implémentation du Parser Minishell

## 1. Vue d'ensemble de l'Architecture

Le parser du minishell est constitué de trois composants principaux qui fonctionnent en séquence :

1. **Lexer (Analyseur lexical)**
   - Transforme l'entrée brute en tokens
   - Gère l'identification des différents types de tokens
   - Maintient le contexte pendant l'analyse (quotes, espaces)

2. **Parser (Analyseur syntaxique)**
   - Organise les tokens en commandes structurées
   - Vérifie la validité syntaxique
   - Construit l'arbre de commandes

3. **Command Builder**
   - Transforme l'arbre syntaxique en commandes exécutables
   - Prépare les redirections et les pipes
   - Configure l'environnement d'exécution

## 2. Plan d'Implémentation Détaillé

### Phase 1 : Lexer (t_lexer)

```c
/* Structure du lexer */
struct s_lexer {
    char    *input;         // Entrée brute
    int     pos;           // Position actuelle
    int     length;        // Longueur de l'entrée
    t_token *current;      // Token en cours d'analyse
    bool    in_quotes;     // État des quotes
    int     quote_type;    // Type de quote (simple/double)
};
```

Étapes d'implémentation :
1. Initialisation du lexer
2. Identification des tokens :
   - Mots (commandes, arguments)
   - Opérateurs (|, >, >>, <)
   - Variables d'environnement
   - Quotes (simples et doubles)
3. Gestion des cas spéciaux :
   - Expansion des variables
   - Heredocs

### Phase 2 : Parser (t_parsing)

```c
/* Structure du parser */
struct s_parsing {
    t_token     *tokens;    // Liste des tokens
    int         index;      // Index actuel
    t_cmd_list  *commands;  // Liste des commandes
    bool        error;      // État d'erreur
    t_heredoc   *heredocs;  // Liste des heredocs
};
```

Étapes d'implémentation :
1. Analyse de la structure de commande
2. Validation syntaxique
3. Construction de l'arbre de commandes
4. Gestion des erreurs de syntaxe

### Phase 3 : Command Builder (t_cmd_list)

```c
/* Structure de commande */
struct s_cmd_list {
    char        **args;     // Arguments de la commande
    t_redir     *redirs;    // Liste des redirections
    int         pipe_in;    // FD entrée du pipe
    int         pipe_out;   // FD sortie du pipe
    t_cmd_list  *next;      // Commande suivante
    t_env       *env;       // Environnement
};
```

## 3. Tests et Validation

### Tests du Lexer
1. Tokenisation basique
   ```bash
   ls -la
   echo "hello world"
   cat file | grep pattern
   ```

2. Cas spéciaux
   ```bash
   echo "quoted 'string' here"
   ls > output 2>&1
   cat << EOF
   ```

### Tests du Parser
1. Structures de commandes
   ```bash
   cmd1 | cmd2 | cmd3
   cmd > file < input
   cmd1 && cmd2 || cmd3
   ```

2. Gestion d'erreurs
   ```bash
   cmd1 ||| cmd2
   cmd > > file
   cmd < 
   ```

## 4. Points d'Attention

1. **Gestion de la Mémoire**
   - Libération correcte des structures
   - Pas de fuites dans les cas d'erreur
   - Gestion propre des buffers

2. **Robustesse**
   - Validation des entrées
   - Récupération sur erreur
   - Protection contre les cas limites

3. **Performance**
   - Optimisation des allocations
   - Limitation des copies
   - Efficacité des parcours

## 5. Documentation du Code

Exemple de documentation pour les fonctions principales :

```c
/**
 * lexer_create - Initialise un nouveau lexer
 * @input: Chaîne d'entrée à analyser
 * 
 * Cette fonction crée et initialise une nouvelle instance du lexer.
 * Elle alloue la mémoire nécessaire et configure les états initiaux.
 * 
 * Return: Pointeur vers le nouveau lexer, NULL en cas d'erreur
 */
t_lexer *lexer_create(const char *input);

/**
 * parser_parse_command - Analyse une commande complète
 * @parser: Instance du parser
 * 
 * Parse une commande complète, incluant ses arguments et redirections.
 * Gère les pipes et les opérateurs de contrôle.
 * 
 * Return: Nouvelle commande parsée, NULL en cas d'erreur
 */
t_cmd_list *parser_parse_command(t_parsing *parser);
```

## 6. Extensions Futures

1. Support des fonctionnalités avancées :
   - Substitution de commandes
   - Expansion des jokers 
   - Historique des commandes

2. Optimisations possibles :
   - Cache de tokens
   - Analyse parallèle
   - Pré-compilation des motifs

## 7. Ressources Utiles

- Documentation POSIX sur la syntaxe shell
- Manuel de référence Bash
- Spécifications des redirections UNIX
- Documentation sur les expressions régulières

Cette documentation servira de guide tout au long du développement et pourra être enrichie au fur et à mesure de l'avancement du projet.
